
For overall : see #high_level_systems

features so far:
	data structures: array, hash map (robin hood open addressing), queue, stack, vector, string, heap
	allocation context system + arena allocators, joint allocation, etc.
	asset processing & loading: images, fonts, font atlasing
	event based input system
	metaprogramming: context, call stack, type reflection info, any-type printf
	flexible IMGUI system 
	threaded extensible logging system
	vector/matrix math
	opengl rendering system
	windows platform layer
		linux platform layer soon...
	job based thread pool async system, event or callback driven

all includes:
	#include <stdarg.h>
	#include <stdint.h>
	#include <float.h>
	#include <new>
	#include <cmath>
	#include <xmmintrin.h>
	#include <typeinfo>

working:
	Fixing OpenGL system
	Move geometry rendering into meshes (out of GUI)
		Move font stuff into new file - sizing, etc.
	GUI window layout - scroll, clip, multiple meshes, text layout

	Profiler rendering
	SDL platform layer

to do:

	data structures
		list (same API as vector, but chunked & no-copy)
		strings
			string builder
			could improve cache locality by doing gb-string style header then data (also can use as c_str automatically)
		improve map storage/AOS
			try separate vectors of keys, values, hashes (no map_element)
		concurrent
			dequeue for work-stealing
			vector
			map

	allocation stuff
		free list (one-size pool re-using arenas)

	async
		better integration with event system https://www.youtube.com/watch?v=gFFqYLgPOWI
		job chaining

	uncategorized
		SIMD & intrinsic math (vectorized functions, vector/mat math, noise & randomness)
		stack allocations (_malloca? can't easily platform-abstract this...) where possible
		ideal - no allocate/free per frame

	meta
		printf
			use string builder?
			increase speed; recursive calls are quite slow (...might not be able to get rid of the recursion, though)
		do we want to do a subtype dispatcher? https://youtu.be/lCtALewoFjc?t=1h20m16s
		integration with UI
		support loading/writing type table for release (i.e. don't build on startup)

	debug
		stats/options 
			apply meta-types
		profiler
			frame buffer
			graphs
			sections
			functions
			display - hierarchal, per time, etc. See Code Modification Jai Demo
		Interesting - https://github.com/Srekel/the-debuginator/
		Do we want to use CaptureStackBackTrace instead of keeping the call stack ourself? Probably...

	log
		can we remove allocation on message send?
			pool allocator/free list?
		colorful console output
		keep & output statistics

	UI
		Split textured mesh2D and colored mesh2D
		Use multiple render commands per window - shapes vs. each font vs. user textures
		fonts
			just pack the TTF and use stb_tt to asynchronously cache correctly sized fonts
			when they're needed. 
		widgets
			clipping/wrapping/auto-layout
			dividers
			text input
			multiple fonts
			image widgets - do we need this?
			texture arrays? would be useful for multiple fonts as well
			text wrapping
			lots of other input types (float, text, check-box, key, etc.)
		general window scroll
			click/drag/hold scroll bar
			sticky scroll (like twitch chat)
		logger UI window
			swap between levels
			tooltip call stack / file:line
			console + commands (expose Lua API?)
		profiler
			telemetry-style
		Subl_remote_open for profiler & logging

	asset
		Can we just define mods as asset packs?
			Yes if we include logic 
		add shaders as assets
		asset texture atlases
		call asset.exe to re/build (do path stuff, platform_exec_cmd)
		auto-reload asset stores
		asset manager (general allocator?)
		more types of assets: 
			Modding: Lua scripts/DLLs
			Config Files
			3D Models

	modding system
		API considerations
		API exposed to both C-DLL & Lua
			embedding Lua 
			debugging Lua
			dynamic reload

	fonts
		color/format specifications in string
		extra kerning pairs

	platform
		assure LPARAM/WPARAM size based on 32/64 bit
		Keep window updating during resize/move
		async
			File IO
			Networking
		Experiment with allocation systems
			HeapAlloc/VirtualAlloc
			TLSF (for arena-general allocations?)
			dlmalloc, jemalloc, ptmalloc2, tcmalloc, nedmalloc
			http://blog.reverberate.org/2009/02/one-malloc-to-rule-them-all.html
			Definitely try je & tc
		wgl extension testing/loading
		file change watcher/callback system - maybe not?
		linux platform layer

	OpenGl
		remove sending on every command
			mark mesh as dirty to send
		AZDO (bindless?)
		improve shader spec API
		3D
			texture arrays?
			models & animation
		rename ogl stuff to "renderer" to facilitate different backends

	chunks
		chunk meshing, texturing
		deferred mesh re/building
		LOD
		storage representation (compression?)
		paging
		world storage (3D chunks?)

Stuff from #high_level_systems

Systems
    Debug
        Logging
        Profiling
            Threading
            Minimum Overhead
            Metaprogramming
        Console
            Metapgramming
        Visualization
        Storage
        Memory
    Rendering
        Chunks
            Meshing
            Texturing 
                Atlases
            Reducing polygon count
            Culling
            Render distance
        UI
            Metaprogramming
                QT sig/slot?
                Tags?
            Menus
            Inventory System
        Animation
            Skeletal
            Procedural
        Model Loading
            Animation
            Formats
        Text
            Distance Fields?
            Atlases
            Internationalization
        Minimum draw calls
        OpenGL
            Abstraction layer
            Good shaders
    Memory
        Allocators
        Arena-based
        Allocate at startup?
        Profiling
    Platform
        Windowing
        Events
            Translation
        File IO
        Threading
        Code reloading
        Library loading 
    Sound
        Positional Audio
        Music
    Assets
        Compression?
        Swapping
        Modularity
    Input
        Abstracted input?
        Key bindings
        Controllers
    Networking
        Server/Client Architecture
        Serialization
            Metaprogramming
    World Storage
        Chunks
        Paging
        Serialization
            Metaprogramming
    Simulation
        Logistics
        Physics
    Mods
        Architecture
        Libraries
        API
    Gameplay
        Movement
        Stats
        Inventory
        Building
        Crafting
        Fighting
        Settings