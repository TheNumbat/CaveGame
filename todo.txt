
Large-Scale Improvements | Changes for Future Projects
	less templates, please. But we do need them for data structures...
	rewrite metaprogram for robustness, possibly as a library/outputting a data format
		don't output through pointers? maybe
	don't bother with initialized values/constructors, require all allocated memory zero-initialized
	don't use ::make pattern so much, use .init for not straight POD types
	less callbacks? good, but also not really, they're quite useful. I wish closures didn't need STL and they didn't heap allocate
	probably don't use the futures pattern for the thread pool, go back to event loop
	platform layer can be more elegant
	asset store can be more meta file + data files for hot/cold loading etc. Not sure if necessary though
	use Vulkan

[[[[[[UPDATE THIS]]]]]]
features so far:
	data structures: array, hash map (robin hood open addressing), queue, stack, vector, string, heap
	allocation context system + arena allocators, joint allocation, etc.
	asset processing & loading: images, fonts, font atlasing
	event based input system
	metaprogramming: context, call stack, type reflection info, any-type printf
	flexible IMGUI system 
	threaded extensible logging system
	vector/matrix math
	opengl rendering system
	windows platform layer
		linux platform layer soon...
	job based thread pool async system, event or callback driven
[[[[[[[[[]]]]]]]]]

Everything not by me:
	#include <stdarg.h>
	#include <stdint.h>
	#include <float.h>
	#include <new>
	#include <cmath>
	#include <typeinfo>
	#include <xmmintrin.h>/<intrin.h>

Working To-Do:

	!~~~~~ FIX BUGS ~~~~~!

	fix arena/pool allocation alignment for math objects (currently everything is using default platform alloc)
	config format language
		rewrite metaprogram to use it
	SDL platform layer

	chunk AO/lighting/LOD
	movement physics
	
	gui text wrapping
	profiler graphs/actually good layout-ing?
	threading profiling

Bugs:

	AO broken
		only checks in one direction/vertex
		doesn't check across chunk boundaries

	allocation profiling is somewhat broken for the world system
		sometimes causes crash on quit (while printing allocs)

	textures get recreated? on asset store reload (and not freed?)
		make sure textures are only created once
		asset reload leaks memory
		actually the asset pack reload is kind of broken in general - RESTRUCTURE
			textures need to be updated on the GPU

Overall To-Do List:

	chunk meshing
		current vertex format [order in shader], struct is byte-order reversed on u32 boundary
			0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
			yyyy yyyy yyyy norm zzzz zzzz xxxx xxxx vvvv vvvv uuuu uuuu aoao tttt tttt tttt
		Tradeoff compactness vs. detail - how do we do LOD and special multifaceted blocks?
			do we want different vertex layouts for LOD????

	other voxel structures - SHOULD EXPLORE
		stb_voxel_render approach
			separate vertex/face data
			vertex : 1 byte x 1 byte y 1 byte z 1 byte lighting (2b AO)
			face : 2 byte texture, 1 byte normal/rotation
		Geometry shader cube gen - more complicated, can be very fast, will experiment
		Geometry shader gen from faces
			why is this any better than the cube?
			would this actually be good though? it would likely be similar to meshing but larger/less "vertices"
			Calculate vertex stuff from uniform face data???
		3D texture ray-marching - should explore, probably doesn't make much sense for versatility
			would represent chunks as octrees?

	new build system with clang
		make metaprogram a real compilation step, get rid of PROF

	data structures
		list (same API as vector, but chunked & no-copy)
		strings
			string builder
			could improve cache locality by doing gb-string style header then data (also can use as c_str automatically)
		improve map storage/AOS
			try separate vectors of keys, values, hashes (no map_element)
		concurrent
			dequeue for work-stealing
			vector
			map
		Config file format, loading/writing
			GUI style
			Assets

	allocators
		free list (one-size pool re-using arenas)
		alignment - pool / arena is never aligned
		ideal - no allocate/free per frame

	async
		better integration with event system https://www.youtube.com/watch?v=gFFqYLgPOWI
		better job chaining
		pause/resume job? ~closures~ how do we do this when job != thread?

	uncategorized
		SIMD & intrinsic math (vectorized functions, vector/mat math, noise & randomness)
			try to switch v3/v4/m4 to __m128 - how can we minimize transitions between __m128 / f32?
		stack allocations (_malloca? can't easily platform-abstract this...) where possible

	meta
		serialization/deserialization
			deserialize to type vs deserialize to generic JSON like object [tagged/no tagged]
			data versioning
		config file format
		printf
			use string builder?
			human readable {} printing (with newlines)
			increase speed; recursive calls are quite slow (...might not be able to get rid of the recursion, though)
		do we want to do a subtype dispatcher? https://youtu.be/lCtALewoFjc?t=1h20m16s
		support loading/writing type table for release (i.e. don't build on startup)

	debug
		re-enable arena/pool messages?
		find a way to check net allocations in debug manager?	
		stats/options 
			apply meta-types
		profiler
			graphs
			Allocation / sync profiling
		display - hierarchal, per time, etc. See Code Modification Jai Demo
		Interesting - https://github.com/Srekel/the-debuginator/
		Do we want to use CaptureStackBackTrace instead of keeping the call stack ourself? Probably...

	log
		can we remove allocation on message send?
			pool allocator/free list?
		colorful console output
		keep & output statistics

	UI
		arbitrary render commands per window - different fonts, user textures
		fonts
			just pack the TTF and use stb_tt to asynchronously cache correctly sized fonts
			when they're needed. 
				font_cache
			Don't store font info in window - have text meshes hold font name/size/style
		widgets
			lists
			text wrapping/auto-size
			horizontal scrolling
			dividers
			text input
			image widgets
			texture arrays
			lots of other input types (float, text, check-box, key, etc.)
		Debug UI window
			swap between levels
			tooltip call stack / file:line
			console + commands (Lua API?)
		Subl_remote_open for profiler & logging

	asset
		Can we just define mods as asset packs?
			Yes if we include logic 
		call asset.exe to re/build (do path stuff, platform_exec_cmd)
		auto-reload asset stores
		asset manager (general allocator?)
		more types of assets: 
			Mod Definitions
			Lua scripts
			DLLs
			Config Files
			Shaders
			Texture Atlases/Arrays
			3D Models & Animations
			Sounds

	modding system
		API considerations
		API exposed to both C-DLL & Lua
			embedding LuaJIT 
			debugging LuaJIT
			dynamic reload

	fonts
		color/format specifications in string?
		extra kerning pairs from stb_tt
		Move font stuff into new file - sizing, etc.

	platform
		assure LPARAM/WPARAM size based on 32/64 bit
		Keep window updating during resize/move
			maybe not, this is a pain
		async
			File IO
			Networking - cURL? WinSock? TCP
		Experiment with allocation systems
			learn more about virtual memory
				HeapAlloc/VirtualAlloc
			TLSF (for arena-general allocations?)
			dlmalloc, jemalloc, ptmalloc2, tcmalloc, nedmalloc
				http://blog.reverberate.org/2009/02/one-malloc-to-rule-them-all.html
				Definitely try je & tc
		wgl extension testing/loading
			OpenGL version testing
		file change watcher/callback system - maybe?
			see JBlow catalogs
		SDL platform layer
			linux platform layer

	OpenGl
		Shaders
			preprocessor / shader assets
			tessellation / geometry shaders
		post-processing effects
		HDR
		AZDO (bindless?)
			glNamed operations
			glMapBuffer?
			command lists -> translate from mine
		3D
			models & animation
		rename ogl stuff to "renderer" to facilitate different backends
		improve z-fighting as render distance increases
			http://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html
		animation - skeletal and procedural

	chunks
		LOD?
		storage representation (compression?)
		world storage (3D chunks?)
			paging to disk - serialization, etc.

	game-play
		lots to put here...will do eventually	
