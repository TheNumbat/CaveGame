
For overall : see #high_level_systems

features so far:
	data structures: array, hash map (robin hood open addressing), queue, stack, vector, thread pool, string
	allocation context system + arena allocators, joint allocation, etc.
	asset processing & loading: images, fonts, font atlasing
	event based input system
	metaprogramming: context, call stack, type reflection info, any-type printf
	flexible IMGUI system 
	threaded extensible logging system
	vector/matrix math
	opengl rendering system
	windows platform layer
		linux platform layer soon...

immediate to do:

	data structures
		list (same API as vector, but chunked & no-copy)
		buffer
		circular buffer (+add to queue)
		heap (+priority queue)
		string builder
		improve map storage/AOS
			bit mask for occupancy
			try separate vectors of keys, values, hashes (no map_element)
		concurrent versions of most things

	allocation stuff
		pool allocator (growing arena)
		free list (one-type pool re-using arenas)

	async
		better integration with event system https://www.youtube.com/watch?v=gFFqYLgPOWI
		job chaining

	uncategorized
		get rid of global_state
		SIMD & intrinsic math (vectorized functions, vector/mat math, noise & randomness)
		stack allocations (_malloca? can't easily platform-abstract this...) where possible
		better hotloading management (probably want callback registry)
		ideal - no allocate/free per frame

	meta
		printf
			use string builder?
		do we want to do a subtype dispatcher? https://youtu.be/lCtALewoFjc?t=1h20m16s
		integration with UI
		profiler
		support loading/writing type table for release (i.e. don't build on startup)

	log
		buffer file IO
		can we remove allocation on message send?
			pool allocator/free list?
		colorful console output

	UI
		stop sending mesh every frame (see OpenGL)
		fonts
			we only need alpha data from font textures - compress
			maybe don't pack a bunch of different sizes, just pack the TTF
			 and use stb_tt to regenerate correctly sized fonts when they're
			 needed. Do we really need this, though?
		widgets
			clipping/wrapping/auto-layout
			dividers
			multiple fonts
			image widgets - do we need this?
			texture arrays? would be useful for multiple fonts as well
			text wrapping
			lots of other input types (float, text, check-box, key, etc.)
		general window scroll
			click/drag/hold scroll bar
			sticky scroll (like twitch chat)
		logger UI window
			swap between levels
			tooltip call stack / file:line
			console + commands
		profiler
			lots to do here

	asset
		asset texture atlases
		call asset.exe to re/build (do path stuff, platform_exec_cmd)
		auto-reload asset stores
		asset manager (general allocator?)
		more types of assets: modding system

	modding system
		Lua
			embedding Lua 
			debugging Lua
			dynamic reload
		think about mod API structure

	fonts
		color/format specifications in string
		extra kerning pairs

	platform
		async file io?
		Experiment with allocation systems
			HeapAlloc/VirtualAlloc
			TLSF (for arena-general allocations?)
			dlmalloc
			jemalloc
			ptmalloc2
			tcmalloc
			nedmalloc
			http://blog.reverberate.org/2009/02/one-malloc-to-rule-them-all.html
			Definitely try je & tc
		wgl extension testing/loading
		file change watcher/callback system - maybe not?
		linux platform layer

	OpenGl
		remove sending on every command
		start AZDO style (bindless?)
		improve shader spec API
		3D
			texture arrays?
			models & animation
		rename ogl stuff to "renderer" to facilitate different backends

	chunks
		chunk meshing, texturing
		deferred mesh re/building
		LOD
		storage representation (compression?)
		paging
		world storage (3D chunks?)


